# 深入理解JVM

* jconsole
* jvisualvm
* jmap
* 助记符
  * ldc：表示将int、float或者String类型的常量值从常量池中推送至栈顶
  * bipush：表示将单字节（-128~127）的常量值推送至栈顶
  * sipush：表示将一个短整型常量值（-32768~32767）推送至栈顶
  * iconst_1：表示将int类型1推送至栈顶（iconst_m1~iconst_2,即-1,0到5）
  * anewarray：表示创建一个引用类型（如类、接口、数组）的数组，并将其引用值压入栈顶
  * newarray：表示创建一个指定的原始类型（如int、float、char等）的数组，并将其引用值压入栈顶

[TOC]

## 一、JVM 类加载机制

### 1、类加载简介

* 在Java代码中，类型的**加载**、**连接**与**初始化**过程都是在程序**运行期**间完成的
* 提供了更大的灵活性，增加了更多的可能性
* 类的加载的最终产品是位于**内存中的Class对象**，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口

### 2、类的生命周期

* 类加载的过程包括了加载、连接（验证、准备、解析）、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。

#### 2.1、类的加载、连接与初始化

* 加载
  
  * 查找并加载类的二进制数据
  
  * 指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据取的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区的数据结构
    * 加载.class文件的方式
  
      * 1）从本地系统中直接加载
  
      * 2）通过网络下载.class文件
  
      * 3）从zip，jar等归档文件中加载.class文件
  
      * 4）从专有数据库中提取.class文件
  
      * 5）将Java源文件动态编译为.class文件
* 连接
  * 验证：确保被加载的类的正确性
  * 准备：为类的**静态变量**分配内存，并将其初始化为**默认值**（并非真正的默认值）
  * 解析：在类型的常量池中寻找类、接口、字段和方法的符号引用，把类中的符号引用转换为直接引用
    * 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可
    * 直接引用：直接引用可以是
      * 1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）
      * 2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）
      * 3）一个能间接定位到目标的句柄
* 初始化：**为类的静态变量赋予正确的初始值**
  * 对于静态字段来说，只有直接定义了该字段的类才会被初始化
  * 当一个类在初始化时，要求其父类全部都已经初始化完毕
  * 常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中，本质上调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化，可以理解为常量与定义常量的类在编译成.class文件之后就没有任何关系（删除定义常量的类也不影响该常量）。
  * 当一个常量的值**并非编译期间可以确定**的，那么其值就不会被放到调用类的常量池中。这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化。
  * 对于**数组**实例来说，其类型是由**JVM在运行期动态生成**的，表示为[Lcom.xxx.xxx.xxx这种形式。动态生成的类型，其父类型就是Object。对于数组来说，JavaDoc经常将构成数组的元素为component，实际上就是将数组降低一个维度后的类型。
  * 当一个**接口**在初始化时，并不要求其父接口都完成了初始化。只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化。
  * -XX:+TraceClassLoading，用于追踪类的加载信息并打印
    * -XX:+<option>：表示开启option选项
    * -XX:-<option>：表示开启option选项
    * -XX:<option>=<value>：表示将option选项的值设置为value

* 类实例化：
  * 为新的对象分配内存
  * 为实例变量赋默认值
  * 为实例变量赋正确的初始值
  * Java编译器为它编译的每一个类都至少生成一个实例初始化方法。在Java的class文件中，这个实例初始化方法被称为“<init>”。针对源代码中每一个类的构造方法，Java编译器都会产生一个“<init>”方法

#### 2.2、类的使用和卸载

* 使用
  
  * 当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码
  * Java程序对类的使用方式分为两种
    * 主动使用（七种）
      * 创建类的实例
      * 访问某个类或接口的静态变量（getstatic），或者对该静态变量赋值（putstatic）
      * 调用类的静态方法（invokestatic）
      * 反射
      * 初始化一个类的子类
      * Java虚拟机启动时被标明为启动类的类
      * JDK1.7开始提供的动态语言支持：java.land.invoke.MethodHandle实例的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类没有初始化，则初始化
    * 被动使用：除了上面七种情况，其他使用Java类的方式都被看作是对类的**被动使用**，都不会导致类的**初始化**
  
  * 所有的Java虚拟机实现必须在每个类或接口被Java程序“**首次主动使用**”时才初始化它们
  
* 卸载
  
  * 当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存
  * 在如下几种情况下，Java虚拟机将结束生命周期
    - 执行了System.exit()方法
    - 程序正常执行结束
    - 程序在执行过程中遇到了异常或者错误而异常终止
    - 由于操作系统出现错误而导致Java虚拟机进程终止

### 3、类加载器

#### 3.1类加载分类（两种）

* Java虚拟机自带的加载器
  * 根类加载器（Bootstrap）
  * 扩展类加载器（Extension）
  * 系统（应用）类加载器（System）
* 用户自定义的类加载器
  * java.lang.ClassLoader的子类
  * 用户可以定制类的加载方式

#### 3.2类加载器机制

* 类加载器并不需要等到某个类被“首次主动使用”时再加载它
* JVM规范允许类加载在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或者存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）
* 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误