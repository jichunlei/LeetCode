# 33. 搜索旋转排序数组

### 题目描述

* 假设按照**升序**排序的数组在预先未知的某个点上进行了旋转。

* 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` 

* 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的**索引**，否则返回 `-1` 。

* 你可以假设数组中**不存在重复**的元素。

* 你的算法时间复杂度必须是 ***O*(log *n*)** 级别

* 示例

  ```tex
  输入: nums = [4,5,6,7,0,1,2], target = 0
  输出: 4
  
  输入: nums = [4,5,6,7,0,1,2], target = 3
  输出: -1
  ```

### 解题思路

##### 1、解法一：二分法（判断逻辑较繁琐）

* 分析：
  
  * 题目要求时间复杂度为O(log *n*)，则实现必然为二分法，定义start=0，end=length-1起止位，中间位mid=(start+end)/2；
  * 在
  
* 代码实现

  ```java
  /**
    * 解法一：二分法（判断逻辑较繁琐）
    *
    * @param nums   1
    * @param target 2
    * @return: int
    * @auther: xianzilei
    **/
  public static int search1(int[] nums, int target) {
      //如果数组为空，直接返回-1
      if (nums == null || nums.length == 0) {
          return -1;
      }
      //定义起始和截止位置
      int start = 0, end = nums.length - 1;
      while (start < end) {
          int mid = (start + end) / 2;
          //先将三节点（start、end和mid）排除，省去后面的判断需要考虑等于的情况
          if (target == nums[mid]) {
              return mid;
          }
          if (target == nums[start]) {
              return start;
          }
          if (target == nums[end]) {
              return end;
          }
          //情况一：mid>start
          if (nums[mid] > nums[start]) {
              if ((target > nums[start] && target < nums[mid])) {
                  //向左归约
                  end = mid - 1;
              } else {
                  //向右归约
                  start = mid + 1;
              }
          }
          //情况二：mid<start
          else {
              if (target > nums[start] || target < nums[mid]) {
                  //向左归约
                  end = mid - 1;
              } else {
                  //向右归约
                  start = mid + 1;
              }
          }
      }
      return start == end && nums[start] == target ? start : -1;
  }
  ```
  
* 复杂度分析
  * 时间复杂度：
    * O(log n)
  * 空间复杂度：
    * 未开辟新的空间，故空间复杂度为O(1)

##### 2、解法二：二分法（使用异或优化判断逻辑）

- 分析：

  - 从右往左扫描数组，找到第一不满足数组降序的元素位置
    - 未找到：表示数组初始情况满足降序排列，只需修改数组为增序排列即可
    - 找到：只需要将该位置与该元素右边比该元素大的最小元素调换位置，此时排序比原排列大，但是还需要满足条件（下一个比它大），所以还需要将该位置元素的右边排列修改为增序排列（原来为逆序）。

- 代码实现

  ```java
  /**
    * 解法二：二分法（使用异或优化判断逻辑）
    *
    * @param nums   1
    * @param target 2
    * @return: int
    * @auther: xianzilei
    **/
  public static int search2(int[] nums, int target) {
      //定义起止点
      int start = 0, end = nums.length - 1;
      while (start < end) {
          int mid = (start + end) / 2;
          //使用三个条件的异或，省去繁杂的判断逻辑
          if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))
              start = mid + 1;
          else
              end = mid;
      }
      return start == end && nums[start] == target ? start : -1;
  }
  ```

- 复杂度分析

  - 时间复杂度：
    - O(log n)
  - 空间复杂度：
    - 未开辟新的空间，故空间复杂度为O(1)