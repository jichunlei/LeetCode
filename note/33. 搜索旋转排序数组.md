# 33. 搜索旋转排序数组

### 题目描述

* 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

* 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` 

* 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。

* 你可以假设数组中不存在重复的元素。

* 你的算法时间复杂度必须是 *O*(log *n*) 级别

* 示例

  ```tex
  输入: nums = [4,5,6,7,0,1,2], target = 0
  输出: 4
  
  输入: nums = [4,5,6,7,0,1,2], target = 3
  输出: -1
  ```

### 解题思路

##### 1、解法：尾部扫描法

* 分析：
  
  * 从右往左扫描数组，找到第一不满足数组降序的元素位置
    * 未找到：表示数组初始情况满足降序排列，只需修改数组为增序排列即可
    * 找到：只需要将该位置与该元素右边比该元素大的最小元素调换位置，此时排序比原排列大，但是还需要满足条件（下一个比它大），所以还需要将该位置元素的右边排列修改为增序排列（原来为逆序）。
  
* 代码实现

  ```java
  /**
    * 尾部扫描法
    *
    * @param nums
    * @return: void
    * @auther: xianzilei
    **/
  public static void nextPermutation(int[] nums) {
      //目标位置，标记需要修改的位置，初始化为-1
      int target = -1;
      //从最右往左寻找不满足增序的第一个元素位置
      for (int i = nums.length - 1; i > 0; i--) {
          if (nums[i] > nums[i - 1]) {
              target = i - 1;
              break;
          }
      }
      //如果target小于0，表示数组递减，无下一最大值，故只需找最小值（将数组修改为递增即可）
      if (target < 0) {
          reverse(nums, 0, nums.length - 1);
      }
      //否则需要找到对应位置，在其右边找到比大的最小元素（一定存在）
      else {
          //初始化位置为target右边第一位
          int index = target + 1;
          //循环查找右边比target大的最小元素
          while (index < nums.length && nums[target] < nums[index]) {
              index++;
          }
          //交换二者位置的元素
          swap(nums, target, index - 1);
          //将target右边的排列修改为最小，即逆序修改为顺序
          reverse(nums, target + 1, nums.length - 1);
      }
  
  }
  
  //交换数组两位置的元素
  private static void swap(int[] nums, int i, int j) {
      int temp = nums[i];
      nums[i] = nums[j];
      nums[j] = temp;
  }
  
  //反转数组指定位置的元素
  private static void reverse(int[] nums, int start, int end) {
      while (start < end) {
          swap(nums, start, end);
          start++;
          end--;
      }
  }
  ```

* 复杂度分析
  * 时间复杂度：
    * O(n)
  * 空间复杂度：
    * 未开辟新的空间，故空间复杂度为O(1)
